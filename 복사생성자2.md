# 복사생성자2

복사생성자는 언제 호출될까? </br>

```c++
Hero batman(bruce);
```

기존 생성된 객체를 이용해 새로운 객체를 초기화 하는경우 </br>

```c++
int Test(Hero batman)
```

Call-by-value방식으로 함수호출과정에서 객체를 인자로 전달하는 경우 </br>

```c++
Hero Ret_Hero(char* name)
{
  ///empty
}
```

객체를 반환하되 참조형으로 반환하지 않는경우 </br></br>
이 세가지 경우는 모두 객체를 새로 생성 초기화 해야한다는  </br>
공통점이 있다. </br>
반환하는 함수를 작성할 때 return값은 새로 메모리에 할당된다. 	</br>
당연한거다. 그래야 반환값 받을 때 어디에 저장되 있는지 보고 참조해야 하니까 </br>
이를 클래스에 적용해도 똑같다. </br>

```c++
Hero Ret_Hero(Hero h)
{
  return h 
}

int maiN(void)
{
  Hero batman(20);
  Ret_Hero(batman);
  return 0;  
}
```
다음 코드를 보자 콜 바이 밸류로 batman변수를 인자로 넘겨준다.</br>
그럼 함수 매개변수 h는 새로 메모리에 생성 batman을 받아 생성한다. </br>
그리고 h를 리턴할 때 임시객체가 만들어져서 반환한다. </br>
</br>
이제 최종으로 봐보자 객체의 생성과 소멸 시기를 !!! 두둥 </br>

![캡처](https://user-images.githubusercontent.com/43857226/69129076-08d82300-0af1-11ea-9e92-06552cf63ad7.PNG)</br>

![캡처](https://user-images.githubusercontent.com/43857226/69129124-22796a80-0af1-11ea-8701-cdb859a71177.PNG)</br>

출력결과를 하나하나 뜯고맛보고 씹어보자 </br>

1. **130**줄 객체 생성 
2. Test 함수의 p로 복사 
3. **parameter** 주소 출력 p가 생성되면서 출력한 주소와 동일
4. **리턴값 p** 임시객체 생성
5. 파라미터 객체 소멸
6. 리턴할 **임시객체 소멸**
7. Test 함수의 p로 복사 
8. parameter 주소 출력 p가 생성되면서 출력한 주소와 동일
9. 리턴값 **p임시객체** 생성
10. 파라미터 p는 소멸된다아아아아 
11. 참조 ref는 함수를 리턴받는다 **(임시객체의 대입복사)** 그러므로 임시객체와 ref의 두 주소 동일
12. **ref가 참조하는 임시객체 소멸**
13. 130줄 객체 소멸 
